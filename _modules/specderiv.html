<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>specderiv &#8212; spectral-derivatives  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=8cf5aea1" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for specderiv</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.polynomial</span><span class="w"> </span><span class="kn">import</span> <span class="n">Polynomial</span> <span class="k">as</span> <span class="n">poly</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.fft</span><span class="w"> </span><span class="kn">import</span> <span class="n">dct</span><span class="p">,</span> <span class="n">dst</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">warnings</span><span class="w"> </span><span class="kn">import</span> <span class="n">warn</span>


<div class="viewcode-block" id="cheb_deriv">
<a class="viewcode-back" href="../specderiv.html#specderiv.cheb_deriv">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cheb_deriv</span><span class="p">(</span><span class="n">y_n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">t_n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">nu</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">filter</span><span class="p">:</span> <span class="nb">callable</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;Evaluate derivatives with Chebyshev polynomials via discrete cosine and sine transforms. Caveats:</span>

<span class="sd">	- Taking the 1st derivative twice with a discrete method like this is not exactly the same as taking the second derivative.</span>
<span class="sd">	- For derivatives over the 4th, this method presently returns :code:`NaN` at the edges of the domain. Be cautious if passing</span>
<span class="sd">	  the result to another function.</span>

<span class="sd">	Args:</span>
<span class="sd">		y_n (np.ndarray): one-or-multi-dimensional array, values of a function, sampled at cosine-spaced points in the dimension</span>
<span class="sd">			of differentiation.</span>
<span class="sd">		t_n (np.ndarray): 1D array, where the function :math:`y` is sampled in the dimension of differentation. If you&#39;re using</span>
<span class="sd">			canonical Chebyshev points, this will be :code:`x_n = np.cos(np.arange(N+1) * np.pi / N)` (:math:`x \\in [1, -1]`).</span>
<span class="sd">			If you&#39;re sampling on a domain from :math:`a` to :math:`b`, this needs to be :code:`t_n = np.cos(np.arange(N+1) *</span>
<span class="sd">			np.pi / N) * (b - a)/2 + (b + a)/2`. Note the order is high-to-low in the :math:`x` or :math:`t` domain, but low-to-high</span>
<span class="sd">			in :math:`n`. Also note both endpoints are *inclusive*.</span>
<span class="sd">		nu (int): The order of derivative to take.</span>
<span class="sd">		axis (int, optional): For multi-dimensional :code:`y_n`, the dimension along which to take the derivative. Defaults to the</span>
<span class="sd">			first dimension (axis=0).</span>
<span class="sd">		filter (callable, optional): A function or :code:`lambda` that takes the 1D array of wavenumbers, :math:`k = [0, ... N+1]`,</span>
<span class="sd">			and returns a same-shaped array of weights, which get multiplied in to the initial frequency transform of the data,</span>
<span class="sd">			:math:`Y_k`. Can be helpful when taking derivatives of noisy data. The default is to apply #nofilter.</span>
<span class="sd"> </span>
<span class="sd">	:returns: (*np.ndarray*) -- :code:`dy_n`, shaped like :code:`y_n`, samples of the :math:`\\nu^{th}` derivative of the function</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">N</span> <span class="o">=</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span> <span class="c1"># We only have to care about the number of points in the dimension we&#39;re differentiating</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_n</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">t_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;t_n should be 1D and have the same length as y_n along the axis of differentiation&quot;</span><span class="p">)</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t_n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The domain, t_n, should be ordered high-to-low, [b, ... a]. Try sampling with `np.cos(np.arange(N+1) * np.pi / N) * (b - a)/2 + (b + a)/2`&quot;</span><span class="p">)</span>
	<span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">t_n</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_n</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># Trying to be helpful, because sampling is tricky to get right</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">t_n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">+</span> <span class="n">offset</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Your function is not sampled at cosine-spaced points! Try sampling with `np.cos(np.arange(N+1) * np.pi / N) * (b - a)/2 + (b + a)/2`&quot;</span><span class="p">)</span>

	<span class="n">first</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">];</span> <span class="n">first</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="c1"># for accessing different parts of data</span>
	<span class="n">last</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">];</span> <span class="n">last</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span> <span class="n">last</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
	<span class="n">middle</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">];</span> <span class="n">middle</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="n">middle</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">middle</span><span class="p">)</span>
	<span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">];</span> <span class="n">s</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">);</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># for elevating vectors to have same dimension as data</span>

	<span class="n">Y_k</span> <span class="o">=</span> <span class="n">dct</span><span class="p">(</span><span class="n">y_n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="c1"># Transform to frequency domain using the 1st definition of the discrete cosine transform</span>
	<span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="c1"># [1, ... N-1], wavenumber iterator/indices</span>
	<span class="n">k_with_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># [0, ... N], wavenumbers including endpoints</span>
	<span class="k">if</span> <span class="nb">filter</span><span class="p">:</span> <span class="n">Y_k</span> <span class="o">*=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">k_with_ends</span><span class="p">)</span>

	<span class="n">y_primes</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Store all derivatives in theta up to the nu^th, because we need them all for reconstruction.</span>
	<span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nu</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">order</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># odd derivative</span>
			<span class="n">Y_order</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k</span><span class="p">[</span><span class="n">s</span><span class="p">])</span><span class="o">**</span><span class="n">order</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="c1"># Y_prime[k=0 and N] = 0 and so are not needed for the DST</span>
			<span class="n">y_primes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dst</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">Y_order</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="n">M</span><span class="p">)</span> <span class="c1"># d/dtheta y = the inverse transform of DST-1 </span>
				<span class="c1"># = 1/M * DST-1. Extra j for equivalence with IFFT. Im{y_prime} = 0 for real y, so just keep real.</span>
		<span class="k">else</span><span class="p">:</span> <span class="c1"># even derivative</span>
			<span class="n">Y_order</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k_with_ends</span><span class="p">[</span><span class="n">s</span><span class="p">])</span><span class="o">**</span><span class="n">order</span> <span class="o">*</span> <span class="n">Y_k</span> <span class="c1"># Include terms for wavenumbers 0 and N, becase the DCT uses them</span>
			<span class="n">y_primes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dct</span><span class="p">(</span><span class="n">Y_order</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)[</span><span class="n">middle</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="n">M</span><span class="p">)</span> <span class="c1"># the inverse transform of DCT-1 is 1/M * DCT-1.</span>
				<span class="c1"># Slice off ends. Im{y_prime} = 0 for real y, so just keep real.</span>

	<span class="c1"># Calculate the polynomials in x necessary for transforming back to the Chebyshev domain</span>
	<span class="n">numers</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">poly</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span> <span class="c1"># just -1 to start, at order 1</span>
	<span class="n">denom</span> <span class="o">=</span> <span class="n">poly</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># 1 - x^2</span>
	<span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> <span class="c1">#</span>
		<span class="n">q</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span> <span class="c1"># Terms come from the previous derivative, so there are order-1 of them here.</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">numers</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span> <span class="c1"># c = order - term/2</span>
			<span class="n">numers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">denom</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="n">deriv</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">order</span> <span class="o">-</span> <span class="n">term</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">poly</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">p</span> <span class="o">-</span> <span class="n">q</span><span class="p">)</span>
			<span class="n">q</span> <span class="o">=</span> <span class="n">p</span>
		<span class="n">numers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">q</span><span class="p">)</span>
	
	<span class="c1"># Calculate x derivative as a sum of x polynomials * theta-domain derivatives</span>
	<span class="n">dy_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># The middle of dy will get filled with a derivative expression in terms of y_primes</span>
	<span class="n">x_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="c1"># leave off +/-1, because they need to be treated specially anyway</span>
	<span class="n">denom_x</span> <span class="o">=</span> <span class="n">denom</span><span class="p">(</span><span class="n">x_n</span><span class="p">)</span> <span class="c1"># only calculate this once</span>
	<span class="k">for</span> <span class="n">term</span><span class="p">,(</span><span class="n">numer</span><span class="p">,</span><span class="n">y_prime</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">numers</span><span class="p">,</span> <span class="n">y_primes</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span> <span class="c1"># iterating from lower derivatives to higher</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">nu</span> <span class="o">-</span> <span class="n">term</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># c starts at nu - 1/2 and then loses 1/2 for each subsequent term</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">numer</span><span class="p">(</span><span class="n">x_n</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">denom_x</span><span class="o">**</span><span class="n">c</span><span class="p">))[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">y_prime</span>

	<span class="k">if</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Fill in the endpoints. Unfortunately this takes special formulas for each nu.</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">)[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">middle</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">/</span><span class="n">N</span> <span class="o">+</span> <span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">last</span><span class="p">]</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">))[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">middle</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">/</span><span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">N</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">last</span><span class="p">]</span>
	<span class="k">elif</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># And they&#39;re not short formulas either :(</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">k</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">)[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">middle</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">last</span><span class="p">]</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">k</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">))[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">middle</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">N</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> 
	<span class="k">elif</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">k</span><span class="o">**</span><span class="mi">6</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">k</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">)[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">middle</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">15</span><span class="o">*</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="n">N</span><span class="o">*</span><span class="p">((</span><span class="n">N</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">/</span><span class="mi">30</span> <span class="o">-</span> <span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">Y_k</span><span class="p">[</span><span class="n">last</span><span class="p">]</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">k</span><span class="o">**</span><span class="mi">6</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">k</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">))[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">middle</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">15</span><span class="o">*</span><span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">N</span><span class="o">*</span><span class="p">((</span><span class="n">N</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">/</span><span class="mi">30</span> <span class="o">-</span> <span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">N</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">last</span><span class="p">]</span>
	<span class="k">elif</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">k</span><span class="o">**</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">14</span><span class="o">*</span><span class="n">k</span><span class="o">**</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">49</span><span class="o">*</span><span class="n">k</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">36</span><span class="o">*</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">)[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">middle</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">105</span><span class="o">*</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="n">N</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">6</span> <span class="o">-</span> <span class="mi">14</span><span class="o">*</span><span class="n">N</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">49</span><span class="o">*</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">36</span><span class="p">)</span><span class="o">/</span><span class="mi">210</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">last</span><span class="p">]</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">k</span><span class="o">**</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">14</span><span class="o">*</span><span class="n">k</span><span class="o">**</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">49</span><span class="o">*</span><span class="n">k</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">36</span><span class="o">*</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">))[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">middle</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">105</span><span class="o">*</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">6</span> <span class="o">-</span> <span class="mi">14</span><span class="o">*</span><span class="n">N</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">49</span><span class="o">*</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">36</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="mi">210</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">last</span><span class="p">]</span>
	<span class="k">else</span><span class="p">:</span> <span class="c1"># For higher derivatives, leave the endpoints uncalculated</span>
		<span class="n">warn</span><span class="p">(</span><span class="s2">&quot;endpoints set to NaN, only calculated for 4th derivatives and below&quot;</span><span class="p">)</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

	<span class="c1"># The above is agnostic to where the data came from, pretends it came from the domain [-1, 1], but the data may actually be</span>
	<span class="k">return</span> <span class="n">dy_n</span><span class="o">/</span><span class="n">scale</span><span class="o">**</span><span class="n">nu</span> <span class="c1"># smooshed from some other domain. So scale the derivative by the relative size of the t and x intervals.</span></div>



<div class="viewcode-block" id="fourier_deriv">
<a class="viewcode-back" href="../specderiv.html#specderiv.fourier_deriv">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fourier_deriv</span><span class="p">(</span><span class="n">y_n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">t_n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">nu</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">filter</span><span class="p">:</span> <span class="nb">callable</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;Evaluate derivatives with complex exponentials via FFT. Caveats:</span>

<span class="sd">	- Only for use with periodic functions.</span>
<span class="sd">	- Taking the 1st derivative twice with a discrete method like this is not exactly the same as taking the second derivative.</span>
<span class="sd"> </span>
<span class="sd">	Args:</span>
<span class="sd">		y_n (np.ndarray): one-or-multi-dimensional array, values of a period of a periodic function, sampled at equispaced points</span>
<span class="sd">			in the dimension of differentiation.</span>
<span class="sd">		t_n (np.ndarray): 1D array, where the function :math:`y` is sampled in the dimension of differentiation. If you&#39;re using</span>
<span class="sd">			canonical Fourier points, this will be :code:`th_n = np.arange(M) * 2*np.pi / M` (:math:`\\theta \\in [0, 2\\pi)`). If</span>
<span class="sd">			you&#39;re sampling on a domain from :math:`a` to :math:`b`, this needs to be :code:`t_n = np.arange(0, M)/M * (b - a) + a`.</span>
<span class="sd">			Note the lower, left bound is *inclusive* and the upper, right bound is *exclusive*.</span>
<span class="sd">		nu (int): The order of derivative to take.</span>
<span class="sd">		axis (int, optional): For multi-dimensional :code:`y_n`, the dimension along which to take the derivative. Defaults to the</span>
<span class="sd">			first dimension (axis=0).</span>
<span class="sd">		filter (callable, optional): A function or :code:`lambda` that takes the array of wavenumbers, :math:`k = [0, ...</span>
<span class="sd">			\\lfloor \\frac{M}{2} \\rfloor, -\\lfloor \\frac{M}{2} \\rfloor, ... -1]`, and returns a same-shaped array of weights,</span>
<span class="sd">			which get multiplied in to the initial frequency transform of the data, :math:`Y_k`. Can be helpful when taking</span>
<span class="sd">			derivatives of noisy data. The default is to apply #nofilter.</span>

<span class="sd">	:returns: (*np.ndarray*) -- :code:`dy_n`, shaped like :code:`y_n`, samples of the :math:`\\nu^{th}` derivative of the function</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1">#No worrying about conversion back from a variable transformation. No special treatment of domain boundaries.</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_n</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">t_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;t_n should be 1D and have the same length as y_n along the axis of differentiation&quot;</span><span class="p">)</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t_n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The domain, t_n, should be ordered low-to-high, [a, ... b). Try sampling with `np.arange(0, M)/M * (b - a) + a`&quot;</span><span class="p">)</span>

	<span class="n">M</span> <span class="o">=</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
	<span class="k">if</span> <span class="n">M</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># if M has an even length, then we make k = [0, 1, ... M/2 - 1, 0 or M/2, -M/2 + 1, ... -1]</span>
		<span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
		<span class="k">if</span> <span class="n">nu</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># odd derivatives get the M/2th element zeroed out</span>
	<span class="k">else</span><span class="p">:</span> <span class="c1"># M has odd length, so k = [0, 1, ... floor(M/2), -floor(M/2), ... -1]</span>
		<span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>

	<span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">];</span> <span class="n">s</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">);</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># for elevating vectors to have same dimension as data</span>

	<span class="n">Y_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">y_n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">filter</span><span class="p">:</span> <span class="n">Y_k</span> <span class="o">*=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
	<span class="n">Y_nu</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k</span><span class="p">[</span><span class="n">s</span><span class="p">])</span><span class="o">**</span><span class="n">nu</span> <span class="o">*</span> <span class="n">Y_k</span>
	<span class="n">dy_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Y_nu</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">y_n</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Y_nu</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

	<span class="c1"># The above is agnostic to where the data came from, pretends it came from the domain [0, 2pi), but the data may actually</span>
	<span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_n</span><span class="p">[</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">t_n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="c1"># be smooshed from some other domain. So scale the derivative by the</span>
	<span class="k">return</span> <span class="n">dy_n</span><span class="o">/</span><span class="n">scale</span><span class="o">**</span><span class="n">nu</span> 							<span class="c1"># relative size of the t and theta intervals.</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">spectral-derivatives</a></h1>



<p class="blurb">Spectral derivatives with the Chebyshev and Fourier bases</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=pavelkomarov&repo=spectral-derivatives&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Pavel Komarov.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>