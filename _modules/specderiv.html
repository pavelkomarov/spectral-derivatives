<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>specderiv &#8212; spectral-derivatives  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=8cf5aea1" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for specderiv</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.polynomial.chebyshev</span><span class="w"> </span><span class="kn">import</span> <span class="n">chebder</span><span class="p">,</span> <span class="n">chebfit</span><span class="p">,</span> <span class="n">chebval</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.fft</span><span class="w"> </span><span class="kn">import</span> <span class="n">dct</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">warnings</span><span class="w"> </span><span class="kn">import</span> <span class="n">warn</span><span class="p">,</span> <span class="n">catch_warnings</span><span class="p">,</span> <span class="n">simplefilter</span>


<div class="viewcode-block" id="cheb_deriv">
<a class="viewcode-back" href="../specderiv.html#specderiv.cheb_deriv">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cheb_deriv</span><span class="p">(</span><span class="n">y_n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">t_n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">filter</span><span class="p">:</span> <span class="nb">callable</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;Evaluate derivatives with Chebyshev polynomials via series derivative rule.</span>

<span class="sd">	Args:</span>
<span class="sd">		y_n (np.ndarray): one-or-multi-dimensional array, values of a function, sampled at cosine-spaced points in the dimension</span>
<span class="sd">			of differentiation.</span>
<span class="sd">		t_n (np.ndarray): 1D array, where the function :math:`y` is sampled in the dimension of differentation. Use cosine-spaced</span>
<span class="sd">			points, i.e. :code:`t_n = x_n * (b - a)/2 + (b + a)/2` for a domain between :math:`a` and :math:`b`, where</span>
<span class="sd">			:code:`x_n = np.cos(np.arange(N+1) * np.pi / N)`, to enable :math:`O(N \\log N)` transforms to and from the basis domain.</span>
<span class="sd">			Note the ordering of these points counts *up* in :math:`n`, which is right-to-left, from 1 to -1 in the :math:`x` domain.</span>
<span class="sd">			If instead you want to use arbitrary sample points, this is allowed, but the code will warn that you are incurring</span>
<span class="sd">			:math:`O(N^3)` cost. Note both endpoints are *inclusive*.</span>
<span class="sd">		order (int): The order of differentiation, also called :math:`\\nu`. Must be :math:`\\geq 1`.</span>
<span class="sd">		axis (int, optional): For multi-dimensional :code:`y_n`, the dimension along which to take the derivative. Defaults to the</span>
<span class="sd">			first dimension (axis=0).</span>
<span class="sd">		filter (callable, optional): A function or :code:`lambda` that takes the 1D array of Chebyshev polynomial numbers, :math:`k</span>
<span class="sd">			= [0, ... N]`, and returns a same-shaped array of weights, which get multiplied in to the initial frequency transform of</span>
<span class="sd">			the data, :math:`Y_k`. Can be helpful when taking derivatives of noisy data. The default is to apply #nofilter.</span>

<span class="sd">	:returns: (*np.ndarray*) -- :code:`dy_n`, shaped like :code:`y_n`, samples of the :math:`\\nu^{th}` derivative of the function</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">order</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># allow antiderivatives with numpy&#39;s chebint? The trouble is those extra zeros [0, ... coefs]. How do you evaluate that at only N+1 points efficiently?</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;derivative order, nu, should be &gt;= 1&quot;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_n</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">t_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;t_n should be 1D and have the same length as y_n along the axis of differentiation&quot;</span><span class="p">)</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t_n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t_n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;t_n should be monotonically and strictly increasing or decreasing&quot;</span><span class="p">)</span>
	
	<span class="n">first</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">];</span> <span class="n">first</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="c1"># for accessing different parts of data</span>
	<span class="n">last</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">];</span> <span class="n">last</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">last</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
	<span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">];</span> <span class="n">s</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">);</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># for elevating vectors to have same dimension as data</span>

	<span class="n">N</span> <span class="o">=</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># We only have to care about the number of points in the dimension we&#39;re differentiating</span>
	<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t_n</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">t_n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">t_n</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="p">(</span><span class="n">t_n</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t_n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># Trying to be helpful, because sampling is tricky to get right</span>
	<span class="n">cosine_spaced</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">t_n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span> <span class="c1"># enables efficient frequency transforms</span>
	
	<span class="k">if</span> <span class="n">cosine_spaced</span><span class="p">:</span> <span class="c1"># Chebyshev points found, enables DCT-I!</span>
		<span class="n">Y_k</span> <span class="o">=</span> <span class="n">dct</span><span class="p">(</span><span class="n">y_n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">/</span><span class="n">N</span> <span class="c1"># Transform to frequency domain using the 1st definition of the discrete cosine transform</span>
		<span class="c1"># In the IDCT-I we have y_n = 1/2N (Y_0 + (-1)^n Y_N + 2 \sum_{k=1}^{N-1} cos(pi k n/N) Y_k), but in the Chebyshev</span>
		<span class="c1"># expansion we have: y_n = \sum_{k=0}^{N} cos(pi k n/N) a_k. So we need to do some scaling to make Y_k = a_k.</span>
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">):</span> <span class="n">Y_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">2</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Your function is not sampled for the DCT-I, i.e. `t_n = np.cos(np.arange(N+1)*np.pi/N) * (b - a)/2 + (b + a)/2`.</span>
<span class="s2">			`cheb_deriv` using chebfit() and chebval() under the hood, which costs O(N^3) instead of O(N log N).&quot;&quot;&quot;</span><span class="p">)</span>
		<span class="n">x_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_n</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span><span class="o">/</span><span class="n">scale</span> <span class="c1"># We have to work in the domain [-1, 1]</span>
		<span class="n">Y_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">chebfit</span><span class="p">(</span><span class="n">x_n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">axis</span><span class="p">,</span> <span class="n">y_n</span><span class="p">)</span> <span class="c1"># O(N^3) to find each fit</span>

	<span class="k">if</span> <span class="nb">filter</span><span class="p">:</span> <span class="n">Y_k</span> <span class="o">*=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))[</span><span class="n">s</span><span class="p">]</span>
	<span class="n">dY_k</span> <span class="o">=</span> <span class="n">chebder</span><span class="p">(</span><span class="n">Y_k</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">cosine_spaced</span><span class="p">:</span> <span class="c1"># prepare the coefficients for an IDCT-I and then carry it out to evaluate dy_n</span>
		<span class="n">z_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dY_k</span><span class="o">.</span><span class="n">shape</span><span class="p">);</span> <span class="n">z_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span> <span class="c1"># add a block of zeros to the end of the coefficients, so we keep same number of points</span>
		<span class="n">dY_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dY_k</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">z_shape</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
		<span class="n">dY_k</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span> <span class="c1"># We should technically also scale dY_k[last] by 2, but this entry is full of 0s. We should also have to scale up all</span>
		<span class="n">dy_n</span> <span class="o">=</span> <span class="n">dct</span><span class="p">(</span><span class="n">dY_k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># coefs by N to get the DCT coefs, but this just cancels the 2N in the denominator of the IDCT</span>
	<span class="k">else</span><span class="p">:</span> <span class="c1"># evaluate Chebyshev functions themselves, O(N^2) for each one</span>
		<span class="n">dy_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">chebval</span><span class="p">(</span><span class="n">x_n</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dY_k</span><span class="p">)</span>

	<span class="c1"># The above is agnostic to where the data came from, pretends it came from the domain [-1, 1], but the data may actually be</span>
	<span class="k">return</span> <span class="n">dy_n</span><span class="o">/</span><span class="n">scale</span><span class="o">**</span><span class="n">order</span> <span class="c1"># smooshed from some other domain. So scale the derivative by the relative size of the t and x intervals.</span></div>



<div class="viewcode-block" id="fourier_deriv">
<a class="viewcode-back" href="../specderiv.html#specderiv.fourier_deriv">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fourier_deriv</span><span class="p">(</span><span class="n">y_n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">t_n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">filter</span><span class="p">:</span> <span class="nb">callable</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;Evaluate derivatives with complex exponentials via FFT. Caveats:</span>

<span class="sd">	- Only for use with periodic functions.</span>
<span class="sd">	- Taking the 1st derivative twice with a discrete method like this is not exactly the same as taking the second derivative.</span>
<span class="sd"> </span>
<span class="sd">	Args:</span>
<span class="sd">		y_n (np.ndarray): one-or-multi-dimensional array, values of a period of a periodic function, sampled at equispaced points</span>
<span class="sd">			in the dimension of differentiation.</span>
<span class="sd">		t_n (np.ndarray): 1D array, where the function :math:`y` is sampled in the dimension of differentiation. If you&#39;re using</span>
<span class="sd">			canonical Fourier points, this will be :code:`th_n = np.arange(M) * 2*np.pi / M` (:math:`\\theta \\in [0, 2\\pi)`). If</span>
<span class="sd">			you&#39;re sampling on a domain from :math:`a` to :math:`b`, this needs to be :code:`t_n = np.arange(0, M)/M * (b - a) + a`.</span>
<span class="sd">			Note the lower, left bound is *inclusive* and the upper, right bound is *exclusive*.</span>
<span class="sd">		order (int): The order of differentiation, also called :math:`\\nu`. Can be positive (derivative) or negative</span>
<span class="sd">			(antiderivative, raises warning).</span>
<span class="sd">		axis (int, optional): For multi-dimensional :code:`y_n`, the dimension along which to take the derivative. Defaults to the</span>
<span class="sd">			first dimension (axis=0).</span>
<span class="sd">		filter (callable, optional): A function or :code:`lambda` that takes the array of wavenumbers, :math:`k = [0, ...</span>
<span class="sd">			\\frac{M}{2} , -\\frac{M}{2} + 1, ... -1]` for even :math:`M` or :math:`k = [0, ... \\lfloor \\frac{M}{2} \\rfloor,</span>
<span class="sd">			-\\lfloor \\frac{M}{2} \\rfloor, ... -1]` for odd :math:`M`, and returns a same-shaped array of weights, which get</span>
<span class="sd">			multiplied in to the initial frequency transform of the data, :math:`Y_k`. Can be helpful when taking derivatives</span>
<span class="sd">			of noisy data. The default is to apply #nofilter.</span>

<span class="sd">	:returns: (*np.ndarray*) -- :code:`dy_n`, shaped like :code:`y_n`, samples of the :math:`\\nu^{th}` derivative of the function</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_n</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">t_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;t_n should be 1D and have the same length as y_n along the axis of differentiation&quot;</span><span class="p">)</span>
	<span class="n">delta_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t_n</span><span class="p">)</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">delta_t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">delta_t</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The domain, t_n, needs to be equispaced, ordered low-to-high on [a, ... b). Try sampling with `np.arange(0, M)/M * (b - a) + a`&quot;</span><span class="p">)</span>

	<span class="n">M</span> <span class="o">=</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
	<span class="c1"># if M has an even length, then we make k = [0, 1, ... M/2 - 1, 0 or M/2, -M/2 + 1, ... -1]</span>
	<span class="c1"># if M has odd length, k = [0, 1, ... floor(M/2), -floor(M/2), ... -1]</span>
	<span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
	<span class="k">if</span> <span class="n">M</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">order</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># odd derivatives get the Nyquist element zeroed out, if there is one</span>

	<span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">];</span> <span class="n">s</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">);</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># for elevating vectors to have same dimension as data</span>

	<span class="n">Y_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">y_n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">filter</span><span class="p">:</span> <span class="n">Y_k</span> <span class="o">*=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">k</span><span class="p">)[</span><span class="n">s</span><span class="p">]</span>
	<span class="k">with</span> <span class="n">catch_warnings</span><span class="p">():</span> <span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">);</span> <span class="n">Y_nu</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k</span><span class="p">[</span><span class="n">s</span><span class="p">])</span><span class="o">**</span><span class="n">order</span> <span class="o">*</span> <span class="n">Y_k</span> <span class="c1"># if order &lt; 0, we&#39;re dividing by 0 at k=0</span>
	<span class="k">if</span> <span class="n">order</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">Y_nu</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;+c information lost in antiderivative&quot;</span><span class="p">)</span> <span class="c1"># Get rid of NaNs. Enables taking the antiderivative.</span>
	<span class="n">dy_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Y_nu</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">y_n</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Y_nu</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

	<span class="c1"># The above is agnostic to where the data came from, pretends it came from the domain [0, 2pi), but the data may actually</span>
	<span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_n</span><span class="p">[</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">t_n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="c1"># be smooshed from some other domain. So scale the derivative by the</span>
	<span class="k">return</span> <span class="n">dy_n</span><span class="o">/</span><span class="n">scale</span><span class="o">**</span><span class="n">order</span> 						<span class="c1"># relative size of the t and theta intervals.</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">spectral-derivatives</a></h1>



<p class="blurb">Spectral derivatives with the Chebyshev and Fourier bases</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=pavelkomarov&repo=spectral-derivatives&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Pavel Komarov.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>