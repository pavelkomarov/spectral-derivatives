<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>specderiv &#8212; spectral-derivatives  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=8cf5aea1" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for specderiv</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.polynomial</span><span class="w"> </span><span class="kn">import</span> <span class="n">Polynomial</span> <span class="k">as</span> <span class="n">poly</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.fft</span><span class="w"> </span><span class="kn">import</span> <span class="n">dct</span><span class="p">,</span> <span class="n">dst</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">warnings</span><span class="w"> </span><span class="kn">import</span> <span class="n">warn</span><span class="p">,</span> <span class="n">catch_warnings</span><span class="p">,</span> <span class="n">simplefilter</span>


<div class="viewcode-block" id="cheb_deriv">
<a class="viewcode-back" href="../specderiv.html#specderiv.cheb_deriv">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cheb_deriv</span><span class="p">(</span><span class="n">y_n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">t_n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">filter</span><span class="p">:</span> <span class="nb">callable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dct_type</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">calc_endpoints</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;Evaluate derivatives with Chebyshev polynomials via discrete cosine and sine transforms. Caveats:</span>

<span class="sd">	- Taking the 1st derivative twice with a discrete method like this is not exactly the same as taking the second derivative.</span>
<span class="sd">	- For derivatives over the 4th, this method presently returns :code:`NaN` at the edges of the domain. Be cautious if passing</span>
<span class="sd">	  the result to another function.</span>

<span class="sd">	Args:</span>
<span class="sd">		y_n (np.ndarray): one-or-multi-dimensional array, values of a function, sampled at cosine-spaced points in the dimension</span>
<span class="sd">			of differentiation.</span>
<span class="sd">		t_n (np.ndarray): 1D array, where the function :math:`y` is sampled in the dimension of differentation. If you&#39;re using</span>
<span class="sd">			canonical Chebyshev points, this will be :code:`x_n = np.cos(np.arange(N+1) * np.pi / N)` (:math:`x \\in [1, -1]`).</span>
<span class="sd">			If you&#39;re sampling on a domain from :math:`a` to :math:`b`, this needs to be :code:`t_n = np.cos(np.arange(N+1) *</span>
<span class="sd">			np.pi / N) * (b - a)/2 + (b + a)/2`. Note the order is high-to-low in the :math:`x` or :math:`t` domain, but low-to-high</span>
<span class="sd">			in :math:`n`. Also note both endpoints are *inclusive*.</span>
<span class="sd">		order (int): The order of differentiation, also called :math:`\\nu`. Must be :math:`\\geq 1`.</span>
<span class="sd">		axis (int, optional): For multi-dimensional :code:`y_n`, the dimension along which to take the derivative. Defaults to the</span>
<span class="sd">			first dimension (axis=0).</span>
<span class="sd">		filter (callable, optional): A function or :code:`lambda` that takes the 1D array of wavenumbers, :math:`k = [0, ... N]`,</span>
<span class="sd">			and returns a same-shaped array of weights, which get multiplied in to the initial frequency transform of the data,</span>
<span class="sd">			:math:`Y_k`. Can be helpful when taking derivatives of noisy data. The default is to apply #nofilter.</span>
<span class="sd">		dct_type (int, optional): 1 or 2, whether to use DCT-I or DCT-II. Defaults to DCT-I.</span>
<span class="sd">		calc_endpoints (bool, optional): Whether to calculate the endpoints of the answer, in case they are unnecessary for a</span>
<span class="sd">			particular use case. Defaults to True. False silences the NaN warning for order &gt; 4.</span>
<span class="sd"> </span>
<span class="sd">	:returns: (*np.ndarray*) -- :code:`dy_n`, shaped like :code:`y_n`, samples of the :math:`\\nu^{th}` derivative of the function</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1"># We only have to care about the number of points in the dimension we&#39;re differentiating</span>
	<span class="n">N</span> <span class="o">=</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">dct_type</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span> <span class="c1"># if type is 1, we count [0, ... N], if type 2, the endpoints are tacked on additionally</span>
	<span class="n">M</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span> <span class="k">if</span> <span class="n">dct_type</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Normalization factor is larger for DCT-II based on repeats of endpoints in equivalent FFT</span>
	<span class="n">x_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">N</span><span class="p">)</span> <span class="k">if</span> <span class="n">dct_type</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># canonical sampling</span>

	<span class="k">if</span> <span class="n">order</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;derivative order, nu, should be &gt;= 1&quot;</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">dct_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DCT type must be 1 or 2&quot;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_n</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">t_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;t_n should be 1D and have the same length as y_n along the axis of differentiation&quot;</span><span class="p">)</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t_n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The domain, t_n, should be ordered high-to-low, [b, ... a]. Try sampling with `np.cos(np.arange(N+1) * np.pi / N) * (b - a)/2 + (b + a)/2`&quot;</span><span class="p">)</span>
	<span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">t_n</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_n</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># Trying to be helpful, because sampling is tricky to get right</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">t_n</span><span class="p">,</span> <span class="n">x_n</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;Your function is not sampled appropriately for the DCT-</span><span class="si">{</span><span class="s1">&#39;I&#39;</span><span class="o">*</span><span class="n">dct_type</span><span class="si">}</span><span class="s2"> Try sampling with</span>
<span class="s2">			</span><span class="si">{</span><span class="s1">&#39;`np.cos(np.arange(N+1) * np.pi / N) * (b - a)/2 + (b + a)/2`&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">dct_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span>
<span class="w">			</span><span class="s1">&#39;`np.concatenate(([b], np.cos((np.arange(N+1) + 0.5) * np.pi/(N+1)) * (b - a)/2 + (b + a)/2, [a]))&#39;</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

	<span class="n">first</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">];</span> <span class="n">first</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="c1"># for accessing different parts of data</span>
	<span class="n">last</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">];</span> <span class="n">last</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">last</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
	<span class="n">middle</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">];</span> <span class="n">middle</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="n">middle</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">middle</span><span class="p">)</span>
	<span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">];</span> <span class="n">s</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">);</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># for elevating vectors to have same dimension as data</span>

	<span class="n">Y_k</span> <span class="o">=</span> <span class="n">dct</span><span class="p">(</span><span class="n">y_n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="k">if</span> <span class="n">dct_type</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">dct</span><span class="p">(</span><span class="n">y_n</span><span class="p">[</span><span class="n">middle</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="c1"># Transform to frequency domain using the 1st definition of the discrete cosine transform</span>
	<span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># [0, ... N], Chebyshev basis polynomial (in x)/wavenumber (in theta) iterator</span>
	<span class="k">if</span> <span class="nb">filter</span><span class="p">:</span> <span class="n">Y_k</span> <span class="o">*=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">k</span><span class="p">)[</span><span class="n">s</span><span class="p">]</span>

	<span class="n">y_primes</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Store all derivatives in theta up to the nu^th, because we need them all for reconstruction.</span>
	<span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
		<span class="n">Y_mu</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k</span><span class="p">[</span><span class="n">s</span><span class="p">])</span><span class="o">**</span><span class="n">mu</span> <span class="o">*</span> <span class="n">Y_k</span>
		<span class="k">if</span> <span class="n">mu</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># odd derivative</span>
			<span class="c1"># In DST-I case Y_mu[k=0 and N] = 0 and so are not needed for the DST, so only pass the [middle] entries</span>
			<span class="c1"># In DST-III case, Y_mu[0 and N+1] = 0. roll() shifts to the left, so Y&#39;_0 is treated like Y&#39;_{N+1}, and we pass in starting at k=1</span>
			<span class="n">y_primes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dst</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">Y_mu</span><span class="p">[</span><span class="n">middle</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="n">M</span> <span class="k">if</span> <span class="n">dct_type</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1"># d/dtheta y = the inverse transform of DST-1 = 1/M * DST-1. Extra j for equivalence with IFFT.</span>
				<span class="k">else</span> <span class="n">dst</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">Y_mu</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="n">M</span><span class="p">)</span> <span class="c1"># inverse of DST-II is 1/M * DST-III. Im{y_prime} = 0 for real y, so just keep real.</span>
		<span class="k">else</span><span class="p">:</span> <span class="c1"># even derivative</span>
			<span class="n">y_primes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dct</span><span class="p">(</span><span class="n">Y_mu</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)[</span><span class="n">middle</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="n">M</span> <span class="k">if</span> <span class="n">dct_type</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1"># the inverse transform of DCT-1 is 1/M * DCT-1. Slice off ends to get same length as DST-I result.</span>
				<span class="k">else</span> <span class="n">dct</span><span class="p">(</span><span class="n">Y_mu</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="n">M</span><span class="p">)</span> <span class="c1"># inverse of DCT-II is 1/M * DCT-III. Im{y_prime} = 0 for real y, so just keep real.</span>

	<span class="c1"># Calculate the polynomials in x necessary for transforming back to the Chebyshev domain</span>
	<span class="n">numers</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">poly</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span> <span class="c1"># just -1 to start, at order 1</span>
	<span class="n">denom</span> <span class="o">=</span> <span class="n">poly</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># 1 - x^2</span>
	<span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> <span class="c1"># initialization takes care of order 1, so iterate from order 2</span>
		<span class="n">q</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nu</span><span class="p">):</span> <span class="c1"># Terms come from the previous derivative, so there are nu - 1 of them here.</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">numers</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span> <span class="c1"># c = nu - mu/2</span>
			<span class="n">numers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">denom</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="n">deriv</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">nu</span> <span class="o">-</span> <span class="n">mu</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">poly</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">p</span> <span class="o">-</span> <span class="n">q</span><span class="p">)</span>
			<span class="n">q</span> <span class="o">=</span> <span class="n">p</span>
		<span class="n">numers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">q</span><span class="p">)</span>
	
	<span class="c1"># Calculate x derivative as a sum of x polynomials * theta-domain derivatives</span>
	<span class="n">dy_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># The middle of dy will get filled with a derivative expression in terms of y_primes</span>
	<span class="n">denom_x</span> <span class="o">=</span> <span class="n">denom</span><span class="p">(</span><span class="n">x_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># only calculate this once; leave off +/-1, because they need to be treated specially anyway</span>
	<span class="k">for</span> <span class="n">term</span><span class="p">,(</span><span class="n">numer</span><span class="p">,</span><span class="n">y_prime</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">numers</span><span class="p">,</span> <span class="n">y_primes</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span> <span class="c1"># iterating from lower derivatives to higher</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">order</span> <span class="o">-</span> <span class="n">term</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># c starts at nu - 1/2 and then loses 1/2 for each subsequent term</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">numer</span><span class="p">(</span><span class="n">x_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">denom_x</span><span class="o">**</span><span class="n">c</span><span class="p">))[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">y_prime</span>

	<span class="c1"># Calculate the endpoints</span>
	<span class="k">if</span> <span class="n">order</span> <span class="o">&lt;=</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">calc_endpoints</span><span class="p">:</span>
		<span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,),</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">15</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[(</span><span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">105</span><span class="p">]}[</span><span class="n">order</span><span class="p">]</span> <span class="c1"># Constants from the math. See the notebook in the warning.</span>
		<span class="n">LH</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># L&#39;HÃ´pital numerator terms</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">C_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="c1"># i starts at 1</span>
			<span class="n">LH</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">C_i</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">i</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">dct_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">LH</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">C_i</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">i</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="c1"># because Nth element is outside the 2\sum in the DCT-I</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">LH</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">/</span> <span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="n">M</span><span class="p">)</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">LH</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">))[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">order</span> <span class="o">*</span> <span class="n">D</span><span class="o">*</span><span class="n">M</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span> <span class="c1"># For higher derivatives, leave the endpoints uncalculated, but direct the user to my analysis of this problem.</span>
		<span class="k">if</span> <span class="n">calc_endpoints</span><span class="p">:</span> <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;endpoints set to NaN, only calculated for 4th derivatives and below. For help with higher derivatives,</span>
<span class="s2">			see https://github.com/pavelkomarov/spectral-derivatives/blob/main/notebooks/chebyshev_domain_endpoints.ipynb&quot;&quot;&quot;</span><span class="p">)</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="n">dy_n</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

	<span class="c1"># The above is agnostic to where the data came from, pretends it came from the domain [-1, 1], but the data may actually be</span>
	<span class="k">return</span> <span class="n">dy_n</span><span class="o">/</span><span class="n">scale</span><span class="o">**</span><span class="n">order</span> <span class="c1"># smooshed from some other domain. So scale the derivative by the relative size of the t and x intervals.</span></div>



<div class="viewcode-block" id="fourier_deriv">
<a class="viewcode-back" href="../specderiv.html#specderiv.fourier_deriv">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fourier_deriv</span><span class="p">(</span><span class="n">y_n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">t_n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">filter</span><span class="p">:</span> <span class="nb">callable</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;Evaluate derivatives with complex exponentials via FFT. Caveats:</span>

<span class="sd">	- Only for use with periodic functions.</span>
<span class="sd">	- Taking the 1st derivative twice with a discrete method like this is not exactly the same as taking the second derivative.</span>
<span class="sd"> </span>
<span class="sd">	Args:</span>
<span class="sd">		y_n (np.ndarray): one-or-multi-dimensional array, values of a period of a periodic function, sampled at equispaced points</span>
<span class="sd">			in the dimension of differentiation.</span>
<span class="sd">		t_n (np.ndarray): 1D array, where the function :math:`y` is sampled in the dimension of differentiation. If you&#39;re using</span>
<span class="sd">			canonical Fourier points, this will be :code:`th_n = np.arange(M) * 2*np.pi / M` (:math:`\\theta \\in [0, 2\\pi)`). If</span>
<span class="sd">			you&#39;re sampling on a domain from :math:`a` to :math:`b`, this needs to be :code:`t_n = np.arange(0, M)/M * (b - a) + a`.</span>
<span class="sd">			Note the lower, left bound is *inclusive* and the upper, right bound is *exclusive*.</span>
<span class="sd">		order (int): The order of differentiation, also called :math:`\\nu`. Can be positive (derivative) or negative</span>
<span class="sd">			(antiderivative, raises warning).</span>
<span class="sd">		axis (int, optional): For multi-dimensional :code:`y_n`, the dimension along which to take the derivative. Defaults to the</span>
<span class="sd">			first dimension (axis=0).</span>
<span class="sd">		filter (callable, optional): A function or :code:`lambda` that takes the array of wavenumbers, :math:`k = [0, ...</span>
<span class="sd">			\\frac{M}{2} , -\\frac{M}{2} + 1, ... -1]` for even :math:`M` or :math:`k = [0, ... \\lfloor \\frac{M}{2} \\rfloor,</span>
<span class="sd">			-\\lfloor \\frac{M}{2} \\rfloor, ... -1]` for odd :math:`M`, and returns a same-shaped array of weights, which get</span>
<span class="sd">			multiplied in to the initial frequency transform of the data, :math:`Y_k`. Can be helpful when taking derivatives</span>
<span class="sd">			of noisy data. The default is to apply #nofilter.</span>

<span class="sd">	:returns: (*np.ndarray*) -- :code:`dy_n`, shaped like :code:`y_n`, samples of the :math:`\\nu^{th}` derivative of the function</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1">#No worrying about conversion back from a variable transformation. No special treatment of domain boundaries.</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_n</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">t_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;t_n should be 1D and have the same length as y_n along the axis of differentiation&quot;</span><span class="p">)</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t_n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The domain, t_n, should be ordered low-to-high, [a, ... b). Try sampling with `np.arange(0, M)/M * (b - a) + a`&quot;</span><span class="p">)</span>

	<span class="n">M</span> <span class="o">=</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
	<span class="c1"># if M has an even length, then we make k = [0, 1, ... M/2 - 1, 0 or M/2, -M/2 + 1, ... -1]</span>
	<span class="c1"># if M has odd length, k = [0, 1, ... floor(M/2), -floor(M/2), ... -1]</span>
	<span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
	<span class="k">if</span> <span class="n">M</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">order</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># odd derivatives get the Nyquist element zeroed out, if there is one</span>

	<span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">y_n</span><span class="o">.</span><span class="n">shape</span><span class="p">];</span> <span class="n">s</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">);</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># for elevating vectors to have same dimension as data</span>

	<span class="n">Y_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">y_n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">filter</span><span class="p">:</span> <span class="n">Y_k</span> <span class="o">*=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">k</span><span class="p">)[</span><span class="n">s</span><span class="p">]</span>
	<span class="k">with</span> <span class="n">catch_warnings</span><span class="p">():</span> <span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">);</span> <span class="n">Y_nu</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k</span><span class="p">[</span><span class="n">s</span><span class="p">])</span><span class="o">**</span><span class="n">order</span> <span class="o">*</span> <span class="n">Y_k</span> <span class="c1"># if nu &lt; 0, we&#39;re dividing by 0</span>
	<span class="k">if</span> <span class="n">order</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">Y_nu</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;+c information lost in antiderivative&quot;</span><span class="p">)</span> <span class="c1"># Get rid of NaNs. Enables taking the antiderivative.</span>
	<span class="n">dy_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Y_nu</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">y_n</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Y_nu</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

	<span class="c1"># The above is agnostic to where the data came from, pretends it came from the domain [0, 2pi), but the data may actually</span>
	<span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_n</span><span class="p">[</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">t_n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="c1"># be smooshed from some other domain. So scale the derivative by the</span>
	<span class="k">return</span> <span class="n">dy_n</span><span class="o">/</span><span class="n">scale</span><span class="o">**</span><span class="n">order</span> 						<span class="c1"># relative size of the t and theta intervals.</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">spectral-derivatives</a></h1>



<p class="blurb">Spectral derivatives with the Chebyshev and Fourier bases</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=pavelkomarov&repo=spectral-derivatives&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Pavel Komarov.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.1</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>